#!/usr/bin/env node

var _ = require('underscore'),
    async = require('async'),
    defaultReporter = require('../lib/reporters/default'),
    gitFileResolver = require('../lib/gitFileResolver'),
    fs = require('fs'),
    optimist = require('optimist');

// Parse arguments
var argparser = optimist
    .boolean(['no-ignore']) // Hack: Inverse if 'ignore'; takes no arguments if boolean
    .usage('$0 <slint.json>')
    .wrap(80)
    .demand(1)
    .options('v', {
        alias: 'verbose',
        boolean: true,
        default: false
    })
    .options('h', {
        alias: 'help',
        boolean: true,
        description: 'Show this help'
    })
    .options('cache', {
        boolean: true,
        default: false,
        description: 'Cache the results of file system operations (experimental)'
    })
    .options('ignore', {
        default: ['node_modules', '3rdparty'],
        description: 'Files and directories to ignore. Use multiple times to set multiple values. Disabled with --no-ignore.'
    });

var args = argparser.argv;

if (args.help) {
    argparser.showHelp();
    process.exit(0);
}

// Fix up args.ignore
if (!args.ignore) { args.ignore = []; }
if (!Array.isArray(args.ignore)) {
    args.ignore = [args.ignore];
}

function printVerbose() {
    if (!args.verbose) { return; }
    process.stdout.write(Array.prototype.slice.call(arguments, 0).join(" ") + '\n');
}

if (args.cache) {
    require('cachedfs').patchInPlace();
}

// Read slint.json
fs.readFile(args._[0], 'utf-8', function (err, rawJson){
    if (err) {
        throw err;
    }
    var json = JSON.parse(rawJson);

    // Run each linter in parallel
    async.map(json, function (directive, cb) {
        printVerbose('Running', JSON.stringify(directive));

        var linter,
            linterFiles = directive.files || ['**'],
            linterSetup = directive.config || {};

        try {
            linter = require('../lib/linters/' + directive.tool);
        } catch (e) {
            return cb(new Error('Failed loading "' + directive.tool + '": ' + e.message));
        }

        // Traverse the file-system to find files to lint
        gitFileResolver(linterFiles, function (err, files) {
            if (err) { return cb(err, []); }

            // Read each file
            async.map(files, function (filename, cb) {
                if (typeof filename !== 'string') {
                    //console.log(linterFiles, 'returns crap', files);
                    return cb();
                }
                fs.readFile(filename, 'utf-8', function (err, data) {
                    if (err) {
                        return cb(undefined, [{
                            filename: filename,
                            message: "Couldn't open file: " + err.message,
                            character: 0,
                            line: 0
                        }]);
                    }
                    printVerbose('Linting', filename, 'with', directive.tool);
                    // Do the actual linting
                    linter(filename, data, linterSetup, cb);
                });
            }, function (err, errorList) {
                if (err) { return cb(err); }
                // Collect the results and pass the joint array back
                return cb(err, _.flatten(errorList));
            });
        });
    }, function (err, errorList) {
        if (err) {
            process.stdout.write('FATAL ERROR: ' + err.message + '\n');
            return;
        }

        // Flatten result-list
        errorList = _.flatten(errorList || []);

        // Pipe the output to the default reporter, pipe that to stdout and
        // wait for it to finish.
        defaultReporter(errorList, {})
            .pipe(process.stdout)
            .on('end', function () {
                // Set error-code to number of errors
                process.exit(errorList ? Math.min(errorList.length, 254) : 0);
            });
    });
});

// vi: filetype=javascript
