#!/usr/bin/env node

var _ = require('underscore'),
    async = require('async'),
    Path = require('path'), // Import with an upper case name so it's less likely to collide with a variable name
    defaultReporter = require('../lib/reporters/default'),
    gitFileResolver = require('../lib/gitFileResolver'),
    fs = require('fs'),
    optimist = require('optimist');

// Parse arguments
var argparser = optimist
    .boolean(['no-ignore']) // Hack: Inverse if 'ignore'; takes no arguments if boolean
    .usage('$0 <slint.json>')
    .wrap(80)
    .demand(1)
    .options('v', {
        alias: 'verbose',
        boolean: true,
        default: false
    })
    .options('h', {
        alias: 'help',
        boolean: true,
        description: 'Show this help'
    })
    .options('cache', {
        boolean: true,
        default: false,
        description: 'Cache the results of file system operations (experimental)'
    })
    .options('git', {
        // TODO: Make it possible to address arbitrary branches/tags/commits, the index or the changes in the index.
        // This is already supported by fsplusgit, it just needs to be mapped to command line switches
        description: 'Work on the staged changes of the current git repository (implicitly turns on --cache)',
        default: false,
        boolean: true
    })
    .options('ignore', {
        default: ['node_modules', '3rdparty'],
        description: 'Files and directories to ignore. Use multiple times to set multiple values. Disabled with --no-ignore.'
    });

var args = argparser.argv;

if (args.help) {
    argparser.showHelp();
    process.exit(0);
}

// Fix up args.ignore
if (!args.ignore) { args.ignore = []; }
if (!Array.isArray(args.ignore)) {
    args.ignore = [args.ignore];
}

function printVerbose() {
    if (!args.verbose) { return; }
    process.stdout.write(Array.prototype.slice.call(arguments, 0).join(" ") + '\n');
}

var baseDir = process.cwd(),
    globDir = baseDir;

if (args.git) {
    require('fsplusgit').patchInPlace();
    require('cachedfs').patchInPlace();
    var cwdFragments = process.cwd().split('/'), // ['', 'foo', 'bar'],
        pathToGitRepo;

    for (var i = cwdFragments.length ; i > 0 ; i -= 1) {
        var ancestorDir = cwdFragments.slice(0, i).join('/'),
            pathToPotentialGitFolder = Path.resolve(ancestorDir, '.git'),
            stats;
        try {
            stats = fs.statSync(pathToPotentialGitFolder);
        } catch (e) {}
        if (stats && stats.isDirectory()) {
            pathToGitRepo = pathToPotentialGitFolder;
            break;
        }
    }
    if (pathToGitRepo) {
        // Change to the same directory relative to the virtual gitFakeFs/HEAD directory:
        var cwdRelativeToWorkingCopy = Path.relative(Path.resolve(pathToGitRepo, '..'), process.cwd()) || '.';

        baseDir = Path.resolve(pathToGitRepo, 'gitFakeFs', 'indexOrWorkingCopy', cwdRelativeToWorkingCopy);
        globDir = Path.resolve(pathToGitRepo, 'gitFakeFs', 'changesInIndex', cwdRelativeToWorkingCopy);
    } else {
        throw new Error('Not inside a git repository');
    }
} else if (args.cache) {
    require('cachedfs').patchInPlace();
}

// Read slint.json
fs.readFile(Path.resolve(baseDir, args._[0]), 'utf-8', function (err, rawJson){
    if (err) {
        throw err;
    }
    var json = JSON.parse(rawJson);

    // Run each linter in parallel
    async.map(json, function (directive, cb) {
        printVerbose('Running', JSON.stringify(directive));

        var linter,
            linterFiles = directive.files || ['**'],
            linterSetup = directive.config || {};

        try {
            linter = require('../lib/linters/' + directive.tool);
        } catch (e) {
            return cb(new Error('Failed loading "' + directive.tool + '": ' + e.message));
        }

        // Traverse the file-system to find files to lint
        gitFileResolver(linterFiles, globDir, function (err, files) {
            if (err) { return cb(err, []); }

            // Read each file
            async.mapLimit(files, 100, function (filename, cb) {
                if (typeof filename !== 'string') {
                    //console.log(linterFiles, 'returns crap', files);
                    return cb();
                }
                // Absolutify:
                filename = Path.resolve(baseDir, filename);

                fs.readFile(filename, 'utf-8', function (err, data) {
                    if (err) {
                        return cb(undefined, [{
                            filename: filename,
                            message: "Couldn't open file: " + err.message,
                            character: 0,
                            line: 0
                        }]);
                    }
                    printVerbose('Linting', filename, 'with', directive.tool);
                    // Do the actual linting
                    linter(filename, data, linterSetup, cb);
                });
            }, function (err, errorList) {
                if (err) { return cb(err); }
                // Collect the results and pass the joint array back
                return cb(err, _.flatten(errorList));
            });
        });
    }, function (err, errorList) {
        if (err) {
            process.stdout.write('FATAL ERROR: ' + err.message + '\n');
            return;
        }

        // Flatten result-list
        errorList = _.flatten(errorList || []);

        // Pipe the output to the default reporter, pipe that to stdout and
        // wait for it to finish.
        defaultReporter(errorList, {})
            .pipe(process.stdout)
            .on('end', function () {
                // Set error-code to number of errors
                process.exit(errorList ? Math.min(errorList.length, 254) : 0);
            });
    });
});

// vi: filetype=javascript
